---
phase: 02-oracle-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - oracle-service/src/services/weather.ts
  - oracle-service/src/services/blockchain.ts
  - oracle-service/src/services/scheduler.ts
  - oracle-service/src/index.ts
  - oracle-service/src/abis/MarketFactory.json
  - contracts/script/ExportAbi.s.sol
autonomous: true

must_haves:
  truths:
    - "Weather service aggregates 3 APIs and calculates median"
    - "Blockchain service can resolve markets on-chain"
    - "Scheduler runs resolution at configured times"
    - "Fallback triggers when fewer than 2/3 APIs succeed"
  artifacts:
    - path: "oracle-service/src/services/weather.ts"
      provides: "Weather aggregation with median"
      exports: ["aggregateTemperature"]
      contains: "calculateMedian"
    - path: "oracle-service/src/services/blockchain.ts"
      provides: "Contract interaction"
      exports: ["resolveMarket", "getMarketFactoryContract"]
      contains: "reportPayouts|resolveMarket"
    - path: "oracle-service/src/services/scheduler.ts"
      provides: "Cron scheduling"
      contains: "node-cron|schedule"
    - path: "oracle-service/src/index.ts"
      provides: "Entry point"
      min_lines: 30
  key_links:
    - from: "oracle-service/src/services/weather.ts"
      to: "oracle-service/src/providers/*"
      via: "fetch functions"
      pattern: "fetchFromOpenWeatherMap|fetchFromOpenMeteo|fetchFromTomorrowIo"
    - from: "oracle-service/src/services/blockchain.ts"
      to: "contracts/src/MarketFactory.sol"
      via: "ABI and contract address"
      pattern: "MarketFactory|resolveMarket"
    - from: "oracle-service/src/index.ts"
      to: "oracle-service/src/services/*"
      via: "service initialization"
      pattern: "import.*from.*services"
---

<objective>
Implement weather aggregation, blockchain resolution, and scheduled oracle execution.

Purpose: Connect all the pieces from Plans 01 and 02. The weather service aggregates temperature from 3 providers using median calculation. The blockchain service resolves markets using the MarketFactory contract. The scheduler ties them together, running resolution at configured times.

Output: Complete oracle service that can fetch weather data, aggregate it, and resolve markets on-chain automatically.
</objective>

<execution_context>
@/Users/rasheedelhindi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rasheedelhindi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-oracle-infrastructure/02-RESEARCH.md
@.planning/phases/02-oracle-infrastructure/02-01-SUMMARY.md
@.planning/phases/02-oracle-infrastructure/02-02-SUMMARY.md
@contracts/src/MarketFactory.sol
</context>

<tasks>

<task type="auto">
  <name>Task 1: Export MarketFactory ABI and create weather aggregation service</name>
  <files>
    contracts/script/ExportAbi.s.sol
    oracle-service/src/abis/MarketFactory.json
    oracle-service/src/services/weather.ts
  </files>
  <action>
**Export ABI from Foundry:**

Create contracts/script/ExportAbi.s.sol:
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Script} from "forge-std/Script.sol";

contract ExportAbi is Script {
    function run() external view {
        // This script just ensures contracts compile
        // ABI is extracted using: forge inspect MarketFactory abi
    }
}
```

Run: `cd contracts && forge inspect MarketFactory abi > ../oracle-service/src/abis/MarketFactory.json`

**Create src/services/weather.ts:**

```typescript
import { fetchFromOpenWeatherMap, fetchFromOpenMeteo, fetchFromTomorrowIo } from '../providers/index.js';
import { TemperatureReading, AggregatedTemperature } from '../types/weather.js';
import { CITIES, CityId } from '../config/constants.js';
import { env } from '../config/env.js';
import { logger } from '../utils/logger.js';

function calculateMedian(readings: TemperatureReading[]): number {
  const temps = readings.map(r => r.temperature).sort((a, b) => a - b);
  const mid = Math.floor(temps.length / 2);
  return temps.length % 2 === 0
    ? (temps[mid - 1] + temps[mid]) / 2
    : temps[mid];
}

function validateTemperature(temp: number): boolean {
  // Sanity check: reasonable temperature range
  return temp >= -50 && temp <= 130;
}

export async function aggregateTemperature(cityId: CityId): Promise<AggregatedTemperature | null> {
  const city = CITIES[cityId];

  const results = await Promise.all([
    fetchFromOpenWeatherMap(city.name, env.OPENWEATHERMAP_API_KEY),
    fetchFromOpenMeteo(city.lat, city.lon),
    fetchFromTomorrowIo(city.lat, city.lon, env.TOMORROW_API_KEY),
  ]);

  const validReadings = results.filter((r): r is TemperatureReading =>
    r !== null && validateTemperature(r.temperature)
  );

  logger.info(`Weather fetch for ${cityId}: ${validReadings.length}/3 sources succeeded`);
  validReadings.forEach(r => logger.debug(`  ${r.source}: ${r.temperature}°F`));

  // Require at least 2 of 3 sources
  if (validReadings.length < 2) {
    logger.error(`FALLBACK TRIGGERED: Only ${validReadings.length}/3 sources for ${cityId}`);
    return null;
  }

  return {
    median: calculateMedian(validReadings),
    sources: validReadings.length,
    readings: validReadings,
  };
}
```
  </action>
  <verify>cd oracle-service && npx tsc --noEmit (weather service compiles)</verify>
  <done>MarketFactory ABI exported, weather aggregation service with median calculation</done>
</task>

<task type="auto">
  <name>Task 2: Create blockchain service for market resolution</name>
  <files>
    oracle-service/src/services/blockchain.ts
  </files>
  <action>
Create src/services/blockchain.ts:

```typescript
import { ethers, Contract, Wallet, JsonRpcProvider } from 'ethers';
import { env } from '../config/env.js';
import { logger } from '../utils/logger.js';
import MarketFactoryABI from '../abis/MarketFactory.json' assert { type: 'json' };

let provider: JsonRpcProvider | null = null;
let wallet: Wallet | null = null;
let marketFactory: Contract | null = null;

export function getProvider(): JsonRpcProvider {
  if (!provider) {
    provider = new ethers.JsonRpcProvider(env.BASE_RPC_URL);
  }
  return provider;
}

export function getWallet(): Wallet {
  if (!wallet) {
    wallet = new ethers.Wallet(env.ORACLE_PRIVATE_KEY, getProvider());
  }
  return wallet;
}

export function getMarketFactoryContract(): Contract {
  if (!marketFactory) {
    marketFactory = new ethers.Contract(
      env.MARKET_FACTORY_ADDRESS,
      MarketFactoryABI,
      getWallet()
    );
  }
  return marketFactory;
}

export async function checkWalletBalance(): Promise<string> {
  const balance = await getProvider().getBalance(getWallet().address);
  return ethers.formatEther(balance);
}

export interface ResolutionParams {
  conditionId: string;
  temperature: number;
  lowerBound: number;
  upperBound: number;
}

export async function resolveMarket(params: ResolutionParams): Promise<string> {
  const { conditionId, temperature, lowerBound, upperBound } = params;

  // Determine outcome: YES if temperature is within bracket [lower, upper)
  const isWithinBracket = temperature >= lowerBound && temperature < upperBound;
  const payouts = isWithinBracket ? [1, 0] : [0, 1]; // [YES, NO]

  logger.info(`Resolving market ${conditionId}`);
  logger.info(`  Temperature: ${temperature}°F, Bracket: [${lowerBound}, ${upperBound})`);
  logger.info(`  Outcome: ${isWithinBracket ? 'YES' : 'NO'} wins (payouts: [${payouts}])`);

  const factory = getMarketFactoryContract();

  // Estimate gas with 25% buffer
  const gasEstimate = await factory.resolveMarket.estimateGas(conditionId, payouts);
  const gasLimit = (gasEstimate * 125n) / 100n;

  logger.debug(`Gas estimate: ${gasEstimate}, using limit: ${gasLimit}`);

  const tx = await factory.resolveMarket(conditionId, payouts, { gasLimit });
  logger.info(`Transaction submitted: ${tx.hash}`);

  const receipt = await tx.wait();
  logger.info(`Market resolved in block ${receipt.blockNumber}`);

  return tx.hash;
}
```
  </action>
  <verify>cd oracle-service && npx tsc --noEmit (blockchain service compiles)</verify>
  <done>Blockchain service can resolve markets with gas estimation and logging</done>
</task>

<task type="auto">
  <name>Task 3: Create scheduler and main entry point</name>
  <files>
    oracle-service/src/services/scheduler.ts
    oracle-service/src/index.ts
  </files>
  <action>
**Create src/services/scheduler.ts:**

```typescript
import cron from 'node-cron';
import { MarketConfig } from '../types/market.js';
import { aggregateTemperature } from './weather.js';
import { resolveMarket } from './blockchain.js';
import { logger } from '../utils/logger.js';

const scheduledJobs: Map<string, cron.ScheduledTask> = new Map();

export function scheduleResolution(market: MarketConfig): void {
  const resolutionTime = new Date(market.resolutionTime);

  // Add 1 minute delay to ensure weather data is available
  const scheduledTime = new Date(resolutionTime.getTime() + 60 * 1000);

  // Generate cron expression (minute hour dayOfMonth month dayOfWeek)
  const cronExpression = `${scheduledTime.getUTCMinutes()} ${scheduledTime.getUTCHours()} ${scheduledTime.getUTCDate()} ${scheduledTime.getUTCMonth() + 1} *`;

  const task = cron.schedule(cronExpression, async () => {
    logger.info(`Running scheduled resolution for market ${market.conditionId}`);

    try {
      const weather = await aggregateTemperature(market.city);

      if (!weather) {
        logger.error(`RESOLUTION FAILED: Could not aggregate weather for ${market.city}`);
        logger.error(`Manual intervention required for market ${market.conditionId}`);
        return;
      }

      const txHash = await resolveMarket({
        conditionId: market.conditionId,
        temperature: weather.median,
        lowerBound: market.lowerBound,
        upperBound: market.upperBound,
      });

      logger.info(`Market ${market.conditionId} resolved successfully: ${txHash}`);
    } catch (error) {
      logger.error(`Resolution error for ${market.conditionId}:`, error);
    }

    // Remove job after execution
    scheduledJobs.delete(market.conditionId);
  }, {
    timezone: 'UTC'
  });

  scheduledJobs.set(market.conditionId, task);
  logger.info(`Scheduled resolution for ${market.conditionId} at ${scheduledTime.toISOString()}`);
}

export function cancelResolution(conditionId: string): boolean {
  const task = scheduledJobs.get(conditionId);
  if (task) {
    task.stop();
    scheduledJobs.delete(conditionId);
    logger.info(`Cancelled resolution for ${conditionId}`);
    return true;
  }
  return false;
}

export function getScheduledMarkets(): string[] {
  return Array.from(scheduledJobs.keys());
}
```

**Create src/index.ts:**

```typescript
import { env } from './config/env.js';
import { logger } from './utils/logger.js';
import { checkWalletBalance } from './services/blockchain.js';
import { aggregateTemperature } from './services/weather.js';
import { scheduleResolution, getScheduledMarkets } from './services/scheduler.js';
import { CityId } from './config/constants.js';

async function healthCheck(): Promise<void> {
  logger.info('=== Oracle Service Health Check ===');

  // Check wallet balance
  const balance = await checkWalletBalance();
  logger.info(`Oracle wallet balance: ${balance} ETH`);
  if (parseFloat(balance) < 0.01) {
    logger.warn('Low wallet balance - may not have enough for gas');
  }

  // Test weather API connectivity (optional, only in development)
  if (env.NODE_ENV === 'development') {
    logger.info('Testing weather API connectivity...');
    const testCity: CityId = 'NYC';
    const weather = await aggregateTemperature(testCity);
    if (weather) {
      logger.info(`Weather test passed: ${testCity} = ${weather.median}°F (${weather.sources} sources)`);
    } else {
      logger.warn('Weather test failed - check API keys');
    }
  }

  logger.info('=== Health Check Complete ===');
}

async function main(): Promise<void> {
  logger.info('Starting Weather Oracle Service');
  logger.info(`Environment: ${env.NODE_ENV}`);
  logger.info(`Market Factory: ${env.MARKET_FACTORY_ADDRESS}`);

  await healthCheck();

  // In production, markets would be loaded from chain events or database
  // For now, log that service is ready
  logger.info('Oracle service initialized and ready');
  logger.info('Scheduled markets:', getScheduledMarkets());

  // Keep process alive
  logger.info('Oracle service running. Press Ctrl+C to stop.');
}

main().catch((error) => {
  logger.error('Fatal error:', error);
  process.exit(1);
});
```
  </action>
  <verify>cd oracle-service && npx tsc && node dist/index.js (starts and shows health check - will fail on missing .env which is expected)</verify>
  <done>Scheduler schedules cron jobs, main entry point initializes service with health check</done>
</task>

</tasks>

<verification>
- `cd oracle-service && npx tsc` builds without errors
- `cd oracle-service && node dist/index.js` starts (may fail on missing env vars - expected)
- Weather service aggregates from 3 providers with median calculation
- Blockchain service resolves markets with proper payouts
- Scheduler uses node-cron with UTC timezone
- All services connected in index.ts entry point
</verification>

<success_criteria>
- Weather aggregation calculates median from 2-3 successful API responses
- Blockchain service determines YES/NO outcome from temperature vs bracket
- Scheduler runs resolution 1 minute after configured time
- Fallback mechanism logs error when fewer than 2/3 APIs succeed
- Service starts and performs health check
</success_criteria>

<output>
After completion, create `.planning/phases/02-oracle-infrastructure/02-03-SUMMARY.md`
</output>
