---
phase: 02-oracle-infrastructure
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - oracle-service/src/services/discovery.ts
  - oracle-service/src/index.ts
  - oracle-service/src/abis/MarketFactory.json
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Oracle discovers existing markets from MarketFactory events on startup"
    - "Discovered markets are automatically registered with the scheduler"
    - "Market discovery extracts city, bracket bounds, and resolution time from questionId"
  artifacts:
    - path: "oracle-service/src/services/discovery.ts"
      provides: "Market discovery from chain events"
      exports: ["discoverMarkets", "MarketInfo"]
    - path: "oracle-service/src/index.ts"
      provides: "Discovery integration on startup"
      contains: "discoverMarkets"
  key_links:
    - from: "oracle-service/src/services/discovery.ts"
      to: "MarketFactory contract"
      via: "queryFilter for MarketCreated events"
      pattern: "queryFilter.*MarketCreated"
    - from: "oracle-service/src/services/discovery.ts"
      to: "scheduler.ts"
      via: "scheduleResolution calls"
      pattern: "scheduleResolution"
    - from: "oracle-service/src/index.ts"
      to: "discovery.ts"
      via: "discoverMarkets import and call"
      pattern: "await discoverMarkets"
---

<objective>
Close Gap 1 from verification: Add market discovery mechanism so oracle can detect deployed markets and schedule their resolution automatically.

Purpose: The oracle service has all pieces (weather aggregation, blockchain resolution, scheduler) but nothing calls scheduleResolution because there's no market discovery. This plan connects the infrastructure to actual markets.

Output: Oracle discovers markets from MarketCreated events and schedules them for resolution on startup.

Note on Gap 2 (Market Deployment): This remains DEFERRED per PROJECT decision [01-03]. The CreateTemperatureMarkets script is ready, but testnet deployment requires a funded wallet. Gap closure focuses on discovery mechanism, which can be verified with a local Anvil fork.
</objective>

<execution_context>
@/Users/rasheedelhindi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rasheedelhindi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-oracle-infrastructure/02-VERIFICATION.md

# Existing oracle service code
@oracle-service/src/index.ts
@oracle-service/src/services/scheduler.ts
@oracle-service/src/services/blockchain.ts
@oracle-service/src/types/market.ts
@oracle-service/src/config/constants.ts

# Contract with MarketCreated event
@contracts/src/MarketFactory.sol
@contracts/src/libraries/QuestionLib.sol
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create market discovery service</name>
  <files>
    oracle-service/src/services/discovery.ts
    oracle-service/src/abis/MarketFactory.json
  </files>
  <action>
Create `oracle-service/src/services/discovery.ts` that:

1. Export `MarketInfo` interface extending what's needed for scheduling:
   ```typescript
   export interface MarketInfo {
     conditionId: string;
     marketAddress: string;
     questionId: string;
     city: CityId;
     lowerBound: number;
     upperBound: number;
     resolutionTime: Date;
   }
   ```

2. Export `discoverMarkets()` async function that:
   - Gets MarketFactory contract (use existing getMarketFactoryContract from blockchain.ts, but create a read-only version or use provider directly to avoid wallet requirement for queries)
   - Queries ALL historical `MarketCreated` events using `queryFilter`:
     ```typescript
     const filter = factory.filters.MarketCreated();
     const events = await factory.queryFilter(filter, 0, 'latest');
     ```
   - For each event, decode the questionId to extract:
     - cityId (bytes 4-7, map to CityId string)
     - lowerBound (bytes 8-11, int32 scaled)
     - upperBound (bytes 12-15, int32 scaled)
     - resolutionTime (bytes 16-23, uint64 to Date)
   - Filter out markets where resolutionTime is in the past (already resolved or expired)
   - Return array of MarketInfo objects

3. Decoding logic for questionId (matching QuestionLib.sol):
   ```typescript
   function decodeQuestionId(questionId: string): { cityId: number; lowerBound: number; upperBound: number; resolutionTime: Date } {
     const bn = BigInt(questionId);
     // marketType = (bn >> 224n) & 0xFFFFFFFFn  // Not needed, always temperature
     const cityId = Number((bn >> 192n) & 0xFFn);
     const lowerBound = Number((bn >> 160n) & 0xFFFFFFFFn);
     const upperBound = Number((bn >> 128n) & 0xFFFFFFFFn);
     const resolutionTime = Number((bn >> 64n) & 0xFFFFFFFFFFFFFFFFn);
     return {
       cityId,
       lowerBound: toSignedInt32(lowerBound),
       upperBound: toSignedInt32(upperBound),
       resolutionTime: new Date(resolutionTime * 1000)
     };
   }
   ```

4. Map cityId number to CityId string:
   ```typescript
   const CITY_ID_MAP: Record<number, CityId> = {
     0: 'NYC',
     1: 'CHICAGO',
     2: 'MIAMI',
     3: 'AUSTIN'
   };
   ```

5. Handle signed int32 conversion (for lowerBound/upperBound):
   ```typescript
   function toSignedInt32(n: number): number {
     return n > 0x7FFFFFFF ? n - 0x100000000 : n;
   }
   ```

6. Log each discovered market with city, bracket, and resolution time

Also update `oracle-service/src/abis/MarketFactory.json` to include the MarketCreated event ABI if not present (check first):
```json
{
  "type": "event",
  "name": "MarketCreated",
  "inputs": [
    {"indexed": true, "name": "conditionId", "type": "bytes32"},
    {"indexed": true, "name": "market", "type": "address"},
    {"indexed": false, "name": "questionId", "type": "bytes32"},
    {"indexed": false, "name": "resolutionTime", "type": "uint256"}
  ]
}
```
  </action>
  <verify>
TypeScript compiles without errors:
```bash
cd oracle-service && npx tsc --noEmit
```
  </verify>
  <done>
- discovery.ts exports discoverMarkets and MarketInfo
- decodeQuestionId correctly extracts city, bounds, and resolution time
- Past markets are filtered out
- Type-safe city mapping (number to CityId)
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate discovery into oracle startup</name>
  <files>
    oracle-service/src/index.ts
  </files>
  <action>
Update `oracle-service/src/index.ts` to:

1. Import discoverMarkets and scheduleResolution:
   ```typescript
   import { discoverMarkets } from './services/discovery.js';
   ```
   (scheduleResolution already imported)

2. In `main()`, AFTER healthCheck and BEFORE "service ready" log:
   ```typescript
   // Discover existing markets from chain
   logger.info('Discovering markets from chain...');
   const markets = await discoverMarkets();
   logger.info(`Found ${markets.length} active market(s)`);

   // Schedule each discovered market for resolution
   for (const market of markets) {
     scheduleResolution({
       conditionId: market.conditionId,
       questionId: market.questionId,
       city: market.city,
       resolutionTime: market.resolutionTime,
       lowerBound: market.lowerBound,
       upperBound: market.upperBound,
     });
   }
   ```

3. Update the log after scheduling to show actual count:
   ```typescript
   const scheduled = getScheduledMarkets();
   logger.info(`Oracle service initialized with ${scheduled.length} scheduled market(s)`);
   ```

4. Remove or update the comment on line 40 ("In production, markets would be loaded from chain events or database") since this is now implemented.

5. Handle case where MARKET_FACTORY_ADDRESS is not set (dev mode):
   ```typescript
   if (env.MARKET_FACTORY_ADDRESS) {
     // discovery code
   } else {
     logger.warn('MARKET_FACTORY_ADDRESS not set - skipping market discovery');
   }
   ```
  </action>
  <verify>
1. TypeScript compiles:
   ```bash
   cd oracle-service && npx tsc --noEmit
   ```

2. Oracle starts without errors (with or without MARKET_FACTORY_ADDRESS):
   ```bash
   cd oracle-service && npm run dev
   # Should see "skipping market discovery" if no factory address
   # Or "Found X active market(s)" if factory address set
   ```
  </verify>
  <done>
- Oracle calls discoverMarkets on startup
- Discovered markets are passed to scheduleResolution
- getScheduledMarkets() returns non-empty array when markets exist
- Graceful handling when MARKET_FACTORY_ADDRESS not configured
  </done>
</task>

<task type="auto">
  <name>Task 3: Test discovery with local fork</name>
  <files>
    oracle-service/package.json (add test script if needed)
  </files>
  <action>
Create a verification test using Anvil fork:

1. Start Anvil forking Base Sepolia (or mainnet if no testnet deployment):
   ```bash
   # In one terminal
   anvil --fork-url $BASE_RPC_URL
   ```

2. Deploy test markets using forge script:
   ```bash
   # In another terminal (contracts directory)
   forge script script/CreateTemperatureMarkets.s.sol --rpc-url http://localhost:8545 --broadcast
   ```

3. Configure oracle to use local Anvil:
   ```bash
   BASE_RPC_URL=http://localhost:8545
   MARKET_FACTORY_ADDRESS=<deployed-factory-address>
   ```

4. Run oracle service and verify:
   - "Discovering markets from chain..." appears
   - "Found 20 active market(s)" (4 cities x 5 brackets)
   - Each market logged with city, bracket, resolution time
   - getScheduledMarkets() returns 20 entries

If Anvil fork isn't available, verify by:
1. Unit test that decodeQuestionId correctly parses known questionId values
2. Manual inspection that discovery.ts code matches QuestionLib.sol encoding

Add to package.json scripts:
```json
"test:discovery": "echo 'Run with Anvil fork - see 02-05-PLAN.md Task 3'"
```
  </action>
  <verify>
When run against local Anvil with deployed markets:
```bash
cd oracle-service && npm run dev
# Output includes:
# Discovering markets from chain...
# Found 20 active market(s)
# Scheduled resolution for 0x... at 2026-...
# Oracle service initialized with 20 scheduled market(s)
```
  </verify>
  <done>
- Discovery correctly finds MarketCreated events
- QuestionId decoding matches Solidity encoding
- Markets are scheduled with correct resolution times
- Gap 1 closed: Oracle now discovers and schedules markets
  </done>
</task>

</tasks>

<verification>
Run these checks to verify gap closure:

1. **TypeScript compilation:**
   ```bash
   cd oracle-service && npx tsc --noEmit
   ```

2. **Oracle startup (no factory):**
   ```bash
   cd oracle-service && npm run dev
   # Should log: "MARKET_FACTORY_ADDRESS not set - skipping market discovery"
   ```

3. **Discovery integration (with Anvil fork):**
   - Start Anvil: `anvil --fork-url $BASE_RPC_URL`
   - Deploy markets: `forge script script/CreateTemperatureMarkets.s.sol --rpc-url http://localhost:8545 --broadcast`
   - Run oracle with `MARKET_FACTORY_ADDRESS` set to deployed factory
   - Verify scheduled markets count matches deployed markets

4. **Code verification:**
   - `scheduleResolution` is called (not just imported)
   - `getScheduledMarkets()` returns discovered markets (not empty)
   - Comment on line 40 updated or removed
</verification>

<success_criteria>
Gap 1 (No Market Discovery Mechanism) is CLOSED when:
1. discoverMarkets() queries MarketCreated events from chain
2. questionId decoding extracts city, bounds, and resolution time correctly
3. Discovered markets are passed to scheduleResolution on startup
4. getScheduledMarkets() returns the discovered markets
5. Oracle logs show discovery and scheduling activity

Gap 2 (Markets Not Deployed) remains DEFERRED:
- CreateTemperatureMarkets script is ready
- Deployment requires funded testnet wallet
- Consistent with PROJECT decision [01-03]
- Can be executed anytime without code changes
</success_criteria>

<output>
After completion, create `.planning/phases/02-oracle-infrastructure/02-05-SUMMARY.md`
</output>
