---
phase: 02-oracle-infrastructure
plan: 04
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - contracts/src/libraries/QuestionLib.sol
  - contracts/script/CreateTemperatureMarkets.s.sol
  - contracts/test/TemperatureMarkets.t.sol
autonomous: true

must_haves:
  truths:
    - "Temperature bracket markets exist for all 4 cities"
    - "questionId format encodes city and bracket for oracle parsing"
    - "At least 3 brackets per city available (12+ markets total)"
  artifacts:
    - path: "contracts/src/libraries/QuestionLib.sol"
      provides: "Question ID encoding/decoding"
      contains: "encodeQuestionId|decodeQuestionId"
    - path: "contracts/script/CreateTemperatureMarkets.s.sol"
      provides: "Market creation script"
      contains: "MarketFactory|createMarket|CityLib"
    - path: "contracts/test/TemperatureMarkets.t.sol"
      provides: "Market creation tests"
      min_lines: 40
  key_links:
    - from: "contracts/script/CreateTemperatureMarkets.s.sol"
      to: "contracts/src/MarketFactory.sol"
      via: "createMarket calls"
      pattern: "factory\\.createMarket"
    - from: "contracts/src/libraries/QuestionLib.sol"
      to: "contracts/src/libraries/CityLib.sol"
      via: "CityId encoding"
      pattern: "CityLib\\.CityId|CityId"
---

<objective>
Create temperature bracket markets for all 4 cities to satisfy MARKET-03 requirement.

Purpose: Phase 2 infrastructure is useless without actual markets to resolve. This plan creates the initial set of temperature bracket markets using the MarketFactory, with a structured questionId format that the oracle can parse to understand which city and bracket each market represents.

Output: QuestionLib for encoding market questions, Foundry script to create markets, tests verifying markets exist.
</objective>

<execution_context>
@/Users/rasheedelhindi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rasheedelhindi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-oracle-infrastructure/02-01-SUMMARY.md
@contracts/src/MarketFactory.sol
@contracts/src/libraries/CityLib.sol
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create QuestionLib for encoding market questions</name>
  <files>contracts/src/libraries/QuestionLib.sol</files>
  <action>
Create QuestionLib library that provides a structured questionId format for temperature bracket markets.

**QuestionLib.sol:**
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {CityLib} from "./CityLib.sol";

library QuestionLib {
    // Question ID format (32 bytes):
    // [0-3]:   Market type (0x01 = temperature)
    // [4-7]:   City ID (0-3 for NYC/Chicago/Miami/Austin)
    // [8-11]:  Lower bound (temperature in F, scaled by 100)
    // [12-15]: Upper bound (temperature in F, scaled by 100, 0xFFFF = +infinity)
    // [16-23]: Resolution timestamp
    // [24-31]: Nonce (for uniqueness)

    uint32 constant MARKET_TYPE_TEMPERATURE = 0x01;
    uint32 constant UPPER_BOUND_INFINITY = 0xFFFFFFFF;

    struct TemperatureBracket {
        int32 lowerBound;  // Temperature in F (e.g., 80)
        int32 upperBound;  // Temperature in F (e.g., 85), or type(int32).max for +inf
    }

    function encodeQuestionId(
        CityLib.CityId cityId,
        int32 lowerBound,
        int32 upperBound,
        uint64 resolutionTime,
        uint64 nonce
    ) internal pure returns (bytes32) {
        return bytes32(
            (uint256(MARKET_TYPE_TEMPERATURE) << 224) |
            (uint256(uint8(cityId)) << 192) |
            (uint256(uint32(lowerBound)) << 160) |
            (uint256(uint32(upperBound)) << 128) |
            (uint256(resolutionTime) << 64) |
            uint256(nonce)
        );
    }

    function decodeQuestionId(bytes32 questionId) internal pure returns (
        uint32 marketType,
        CityLib.CityId cityId,
        int32 lowerBound,
        int32 upperBound,
        uint64 resolutionTime,
        uint64 nonce
    ) {
        marketType = uint32(uint256(questionId) >> 224);
        cityId = CityLib.CityId(uint8(uint256(questionId) >> 192));
        lowerBound = int32(uint32(uint256(questionId) >> 160));
        upperBound = int32(uint32(uint256(questionId) >> 128));
        resolutionTime = uint64(uint256(questionId) >> 64);
        nonce = uint64(uint256(questionId));
    }

    // Standard temperature brackets (Fahrenheit)
    function getStandardBrackets() internal pure returns (TemperatureBracket[] memory) {
        TemperatureBracket[] memory brackets = new TemperatureBracket[](5);
        brackets[0] = TemperatureBracket({lowerBound: type(int32).min, upperBound: 70});  // Below 70
        brackets[1] = TemperatureBracket({lowerBound: 70, upperBound: 80});               // 70-80
        brackets[2] = TemperatureBracket({lowerBound: 80, upperBound: 85});               // 80-85
        brackets[3] = TemperatureBracket({lowerBound: 85, upperBound: 90});               // 85-90
        brackets[4] = TemperatureBracket({lowerBound: 90, upperBound: type(int32).max}); // 90+
        return brackets;
    }
}
```

This encoding allows the oracle service to:
1. Parse questionId to extract city and bracket
2. Fetch weather for the correct city
3. Determine if temperature falls in the bracket
4. Resolve with correct payouts
  </action>
  <verify>forge build compiles without errors</verify>
  <done>QuestionLib exists with encode/decode functions and standard brackets</done>
</task>

<task type="auto">
  <name>Task 2: Create Foundry script to deploy temperature markets</name>
  <files>contracts/script/CreateTemperatureMarkets.s.sol</files>
  <action>
Create Foundry script that creates temperature bracket markets for all 4 cities.

**CreateTemperatureMarkets.s.sol:**
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Script, console} from "forge-std/Script.sol";
import {MarketFactory} from "../src/MarketFactory.sol";
import {CityLib} from "../src/libraries/CityLib.sol";
import {QuestionLib} from "../src/libraries/QuestionLib.sol";

contract CreateTemperatureMarkets is Script {
    function run() external {
        address factoryAddress = vm.envAddress("MARKET_FACTORY_ADDRESS");
        MarketFactory factory = MarketFactory(factoryAddress);

        // Resolution time: tomorrow at noon UTC (for demo purposes)
        uint64 resolutionTime = uint64(block.timestamp + 1 days);

        vm.startBroadcast();

        uint64 nonce = 0;

        // Create markets for each city
        CityLib.CityId[4] memory cities = [
            CityLib.CityId.NYC,
            CityLib.CityId.CHICAGO,
            CityLib.CityId.MIAMI,
            CityLib.CityId.AUSTIN
        ];

        // Standard brackets: [<70], [70-80], [80-85], [85-90], [90+]
        QuestionLib.TemperatureBracket[] memory brackets = QuestionLib.getStandardBrackets();

        for (uint256 i = 0; i < cities.length; i++) {
            CityLib.CityId cityId = cities[i];
            CityLib.City memory city = CityLib.getCity(cityId);

            console.log("Creating markets for:", city.name);

            for (uint256 j = 0; j < brackets.length; j++) {
                bytes32 questionId = QuestionLib.encodeQuestionId(
                    cityId,
                    brackets[j].lowerBound,
                    brackets[j].upperBound,
                    resolutionTime,
                    nonce++
                );

                address market = factory.createMarket(questionId, resolutionTime);

                console.log("  Bracket", j, "market:", market);
            }
        }

        vm.stopBroadcast();

        console.log("Created", cities.length * brackets.length, "temperature bracket markets");
    }

    // Utility function to create markets with custom resolution time
    function createMarketsForDate(
        address factoryAddress,
        uint64 resolutionTime
    ) external {
        MarketFactory factory = MarketFactory(factoryAddress);

        vm.startBroadcast();

        uint64 nonce = uint64(resolutionTime); // Use timestamp as nonce base for uniqueness

        CityLib.CityId[4] memory cities = [
            CityLib.CityId.NYC,
            CityLib.CityId.CHICAGO,
            CityLib.CityId.MIAMI,
            CityLib.CityId.AUSTIN
        ];

        QuestionLib.TemperatureBracket[] memory brackets = QuestionLib.getStandardBrackets();

        for (uint256 i = 0; i < cities.length; i++) {
            for (uint256 j = 0; j < brackets.length; j++) {
                bytes32 questionId = QuestionLib.encodeQuestionId(
                    cities[i],
                    brackets[j].lowerBound,
                    brackets[j].upperBound,
                    resolutionTime,
                    nonce++
                );

                factory.createMarket(questionId, resolutionTime);
            }
        }

        vm.stopBroadcast();
    }
}
```

Run with: `forge script script/CreateTemperatureMarkets.s.sol --rpc-url $BASE_RPC_URL --broadcast`

This creates 20 markets (4 cities x 5 brackets).
  </action>
  <verify>forge build compiles script without errors</verify>
  <done>CreateTemperatureMarkets script exists and can create markets for all cities</done>
</task>

<task type="auto">
  <name>Task 3: Write tests verifying market creation and question encoding</name>
  <files>contracts/test/TemperatureMarkets.t.sol</files>
  <action>
Create tests that verify:
1. QuestionLib encoding/decoding roundtrips correctly
2. Markets can be created for all 4 cities
3. Created markets have correct configuration
4. Oracle can parse questionId to get city and bracket

**TemperatureMarkets.t.sol:**
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Test, console} from "forge-std/Test.sol";
import {MarketFactory} from "../src/MarketFactory.sol";
import {PredictionMarket} from "../src/PredictionMarket.sol";
import {SimpleConditionalTokens} from "../src/SimpleConditionalTokens.sol";
import {CityLib} from "../src/libraries/CityLib.sol";
import {QuestionLib} from "../src/libraries/QuestionLib.sol";
import {MockERC20} from "./mocks/MockERC20.sol";

contract TemperatureMarketsTest is Test {
    MarketFactory factory;
    SimpleConditionalTokens ctf;
    MockERC20 collateral;

    function setUp() public {
        collateral = new MockERC20("USDC", "USDC", 6);
        ctf = new SimpleConditionalTokens();
        factory = new MarketFactory(address(ctf), address(collateral));
    }

    function test_QuestionLib_encodeDecodeRoundtrip() public pure {
        CityLib.CityId cityId = CityLib.CityId.NYC;
        int32 lowerBound = 80;
        int32 upperBound = 85;
        uint64 resolutionTime = 1700000000;
        uint64 nonce = 42;

        bytes32 questionId = QuestionLib.encodeQuestionId(
            cityId, lowerBound, upperBound, resolutionTime, nonce
        );

        (
            uint32 decodedType,
            CityLib.CityId decodedCity,
            int32 decodedLower,
            int32 decodedUpper,
            uint64 decodedTime,
            uint64 decodedNonce
        ) = QuestionLib.decodeQuestionId(questionId);

        assertEq(decodedType, QuestionLib.MARKET_TYPE_TEMPERATURE);
        assertEq(uint8(decodedCity), uint8(cityId));
        assertEq(decodedLower, lowerBound);
        assertEq(decodedUpper, upperBound);
        assertEq(decodedTime, resolutionTime);
        assertEq(decodedNonce, nonce);
    }

    function test_QuestionLib_allCitiesEncode() public pure {
        CityLib.CityId[4] memory cities = [
            CityLib.CityId.NYC,
            CityLib.CityId.CHICAGO,
            CityLib.CityId.MIAMI,
            CityLib.CityId.AUSTIN
        ];

        for (uint256 i = 0; i < cities.length; i++) {
            bytes32 questionId = QuestionLib.encodeQuestionId(
                cities[i], 80, 85, 1700000000, uint64(i)
            );

            (, CityLib.CityId decodedCity,,,, ) = QuestionLib.decodeQuestionId(questionId);
            assertEq(uint8(decodedCity), uint8(cities[i]));
        }
    }

    function test_QuestionLib_standardBrackets() public pure {
        QuestionLib.TemperatureBracket[] memory brackets = QuestionLib.getStandardBrackets();

        assertEq(brackets.length, 5);
        // Check bracket 2: [80, 85)
        assertEq(brackets[2].lowerBound, 80);
        assertEq(brackets[2].upperBound, 85);
    }

    function test_createMarketsForAllCities() public {
        CityLib.CityId[4] memory cities = [
            CityLib.CityId.NYC,
            CityLib.CityId.CHICAGO,
            CityLib.CityId.MIAMI,
            CityLib.CityId.AUSTIN
        ];

        uint64 resolutionTime = uint64(block.timestamp + 1 days);
        QuestionLib.TemperatureBracket[] memory brackets = QuestionLib.getStandardBrackets();

        uint256 marketsCreated = 0;

        for (uint256 i = 0; i < cities.length; i++) {
            for (uint256 j = 0; j < 3; j++) { // Create 3 brackets per city for test
                bytes32 questionId = QuestionLib.encodeQuestionId(
                    cities[i],
                    brackets[j].lowerBound,
                    brackets[j].upperBound,
                    resolutionTime,
                    uint64(marketsCreated)
                );

                address market = factory.createMarket(questionId, resolutionTime);
                assertTrue(market != address(0), "Market should be created");

                // Verify market's questionId matches
                PredictionMarket pm = PredictionMarket(market);
                assertEq(pm.questionId(), questionId);

                marketsCreated++;
            }
        }

        // 4 cities x 3 brackets = 12 markets
        assertEq(marketsCreated, 12);
    }

    function test_marketQuestionIdParsableByOracle() public {
        // Simulate oracle parsing a questionId
        CityLib.CityId expectedCity = CityLib.CityId.MIAMI;
        int32 expectedLower = 85;
        int32 expectedUpper = 90;
        uint64 resolutionTime = uint64(block.timestamp + 1 days);

        bytes32 questionId = QuestionLib.encodeQuestionId(
            expectedCity, expectedLower, expectedUpper, resolutionTime, 0
        );

        address marketAddr = factory.createMarket(questionId, resolutionTime);
        PredictionMarket market = PredictionMarket(marketAddr);

        // Oracle would decode the questionId from the market
        bytes32 storedQuestionId = market.questionId();

        (
            ,
            CityLib.CityId cityId,
            int32 lower,
            int32 upper,
            ,
        ) = QuestionLib.decodeQuestionId(storedQuestionId);

        // Oracle now knows:
        // - Fetch weather for Miami (cityId = 2)
        // - Check if temp is in [85, 90)
        assertEq(uint8(cityId), uint8(CityLib.CityId.MIAMI));
        assertEq(lower, 85);
        assertEq(upper, 90);

        // Get city coordinates for API call
        CityLib.City memory city = CityLib.getCity(cityId);
        assertEq(city.name, "Miami");
        assertEq(city.lat, 257617); // 25.7617
    }
}
```
  </action>
  <verify>forge test --match-contract TemperatureMarkets -vv passes all tests</verify>
  <done>All temperature market tests pass, proving question encoding and market creation work</done>
</task>

</tasks>

<verification>
- `forge build` compiles all contracts including QuestionLib
- `forge test --match-contract TemperatureMarkets` passes all tests
- QuestionLib encodes/decodes city + bracket correctly
- CreateTemperatureMarkets script compiles and can create 20 markets
- Markets store questionId that oracle can parse
</verification>

<success_criteria>
- QuestionLib provides structured questionId format for temperature markets
- Foundry script can create markets for all 4 cities x 5 brackets (20 markets)
- Tests verify roundtrip encoding and market creation
- Oracle can parse questionId to determine city and bracket for resolution
- MARKET-03 requirement satisfied: "Temperature bracket markets available"
</success_criteria>

<output>
After completion, create `.planning/phases/02-oracle-infrastructure/02-04-SUMMARY.md`
</output>
