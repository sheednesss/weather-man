---
phase: 02-oracle-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - contracts/src/MarketFactory.sol
  - contracts/src/PredictionMarket.sol
  - contracts/src/libraries/CityLib.sol
  - contracts/test/MarketResolution.t.sol
autonomous: true

must_haves:
  truths:
    - "MarketFactory can resolve markets with payouts array"
    - "Resolved markets reject new trades"
    - "City coordinates are available for oracle lookups"
  artifacts:
    - path: "contracts/src/MarketFactory.sol"
      provides: "resolveMarket function"
      contains: "reportPayouts"
    - path: "contracts/src/libraries/CityLib.sol"
      provides: "City coordinates for 4 cities"
      contains: "NYC|CHICAGO|MIAMI|AUSTIN"
    - path: "contracts/test/MarketResolution.t.sol"
      provides: "Resolution tests"
      min_lines: 50
  key_links:
    - from: "contracts/src/MarketFactory.sol"
      to: "IConditionalTokens.reportPayouts"
      via: "resolveMarket function call"
      pattern: "conditionalTokens\\.reportPayouts"
    - from: "contracts/src/PredictionMarket.sol"
      to: "resolved flag"
      via: "setResolved call from factory"
      pattern: "setResolved|resolved = true"
---

<objective>
Add market resolution capability to smart contracts and define city data for weather markets.

Purpose: Enable the oracle service to resolve markets on-chain with weather data. The MarketFactory (acting as oracle per Phase 1 decision) needs a resolveMarket() function that calls CTF reportPayouts(). City coordinates enable the oracle to fetch weather for specific locations.

Output: MarketFactory with resolveMarket(), PredictionMarket with setResolved(), CityLib with coordinates for NYC/Chicago/Miami/Austin, resolution tests.
</objective>

<execution_context>
@/Users/rasheedelhindi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rasheedelhindi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@contracts/src/MarketFactory.sol
@contracts/src/PredictionMarket.sol
@contracts/src/interfaces/IConditionalTokens.sol
@contracts/src/SimpleConditionalTokens.sol
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CityLib with coordinates for 4 cities</name>
  <files>contracts/src/libraries/CityLib.sol</files>
  <action>
Create CityLib library with:
- Struct for City: name (string), lat (int32), lon (int32) - use int32 for coordinates scaled by 10000 (e.g., 40.7128 becomes 407128)
- Constants for 4 cities:
  - NYC: lat 407128, lon -740060 (40.7128, -74.0060)
  - CHICAGO: lat 418781, lon -876298 (41.8781, -87.6298)
  - MIAMI: lat 257617, lon -801918 (25.7617, -80.1918)
  - AUSTIN: lat 302672, lon -977431 (30.2672, -97.7431)
- Enum CityId { NYC, CHICAGO, MIAMI, AUSTIN }
- Function getCity(CityId) returns City memory
- Function getCityCount() returns 4

Use pure functions, no storage. This is reference data for the oracle service.
  </action>
  <verify>forge build compiles without errors</verify>
  <done>CityLib exists with coordinates for all 4 cities accessible via CityId enum</done>
</task>

<task type="auto">
  <name>Task 2: Add resolution functions to MarketFactory and PredictionMarket</name>
  <files>
    contracts/src/MarketFactory.sol
    contracts/src/PredictionMarket.sol
  </files>
  <action>
**In PredictionMarket.sol:**
- Add `address public immutable factory` (set in constructor, already has this)
- Add `function setResolved() external` that:
  - Requires msg.sender == factory
  - Sets resolved = true
  - Emits MarketResolved event
- Add `event MarketResolved(bytes32 indexed conditionId)`
- Add custom error `OnlyFactory()`

**In MarketFactory.sol:**
- Add `function resolveMarket(bytes32 conditionId, uint256[] calldata payouts) external onlyOwner`:
  - Look up market address from markets mapping
  - Require market exists (revert MarketNotFound if zero address)
  - Get questionId from the market (add getter to PredictionMarket if needed)
  - Call conditionalTokens.reportPayouts(questionId, payouts)
  - Call market.setResolved()
  - Emit MarketResolved event
- Add `event MarketResolved(bytes32 indexed conditionId, uint256[] payouts)`
- Add custom error `MarketNotFound()`

**In PredictionMarket.sol:**
- Add `bytes32 public immutable questionId` (set in constructor - need to pass from factory)
- Update constructor to accept questionId parameter
- Update MarketFactory.createMarket to pass questionId to PredictionMarket constructor

For binary markets (YES/NO), payouts array should be [1, 0] for YES wins or [0, 1] for NO wins.
  </action>
  <verify>forge build compiles without errors</verify>
  <done>MarketFactory has resolveMarket() that calls reportPayouts and sets market resolved</done>
</task>

<task type="auto">
  <name>Task 3: Write resolution tests</name>
  <files>contracts/test/MarketResolution.t.sol</files>
  <action>
Create MarketResolution.t.sol with tests:

1. **test_resolveMarket_YesWins**: Create market, resolve with [1,0], verify:
   - Market resolved flag is true
   - CTF payoutDenominator is set (condition resolved)
   - Further buy() calls revert with MarketResolved

2. **test_resolveMarket_NoWins**: Create market, resolve with [0,1], verify same

3. **test_resolveMarket_onlyOwner**: Non-owner cannot call resolveMarket (revert OwnableUnauthorizedAccount)

4. **test_resolveMarket_marketNotFound**: Resolving non-existent conditionId reverts MarketNotFound

5. **test_resolveMarket_cannotResolveAgain**: Resolving already resolved market reverts (CTF should revert)

6. **test_CityLib_allCities**: Verify all 4 cities have correct coordinates

Use the existing MockConditionalTokens and test setup patterns from PredictionMarket.t.sol.
  </action>
  <verify>forge test --match-contract MarketResolution -vv passes all 6 tests</verify>
  <done>All resolution tests pass, proving resolve flow works end-to-end</done>
</task>

</tasks>

<verification>
- `forge build` compiles all contracts
- `forge test` passes all tests (existing + new resolution tests)
- MarketFactory.resolveMarket exists and calls reportPayouts
- PredictionMarket.setResolved exists and is factory-only
- CityLib returns correct coordinates for all 4 cities
</verification>

<success_criteria>
- MarketFactory can resolve markets with payouts, blocking further trades
- City coordinates available for oracle weather lookups
- 6+ new tests pass validating resolution flow
- Existing 41 tests still pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/02-oracle-infrastructure/02-01-SUMMARY.md`
</output>
