---
phase: 04-web-frontend-mvp
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - web/src/lib/contracts.ts
  - web/src/lib/graphql.ts
  - web/src/hooks/useMarkets.ts
  - web/src/hooks/usePositions.ts
  - web/src/hooks/useMarketsWithWeather.ts
  - web/src/hooks/useVault.ts
  - web/src/types/market.ts
  - web/src/types/position.ts
autonomous: true

must_haves:
  truths:
    - "Contract ABIs imported and typed correctly"
    - "GraphQL queries return market data from Ponder"
    - "useMarkets hook returns markets sorted by volume"
    - "usePositions hook returns user positions with cost basis"
    - "useMarketsWithWeather hook returns markets with weather data"
  artifacts:
    - path: "web/src/lib/contracts.ts"
      provides: "Contract ABIs and address config"
      exports: ["vaultAbi", "predictionMarketAbi", "VAULT_ADDRESS"]
    - path: "web/src/hooks/useMarkets.ts"
      provides: "GraphQL market fetching hook"
      exports: ["useMarkets"]
    - path: "web/src/hooks/usePositions.ts"
      provides: "GraphQL position fetching hook"
      exports: ["usePositions"]
    - path: "web/src/types/market.ts"
      provides: "Market TypeScript types"
      exports: ["Market", "MarketWithWeather"]
  key_links:
    - from: "web/src/hooks/useMarkets.ts"
      to: "http://localhost:42069/graphql"
      via: "graphql-request"
      pattern: "request.*graphql"
    - from: "web/src/hooks/useMarketsWithWeather.ts"
      to: "http://localhost:42069/markets-with-weather"
      via: "fetch"
      pattern: "fetch.*markets-with-weather"
---

<objective>
Create the data layer: import contract ABIs for trading, set up GraphQL client for Ponder queries, and create React hooks for fetching markets, positions, and weather data.

Purpose: Enable components to read blockchain and API data with proper caching via TanStack Query
Output: Type-safe hooks for all data needed by trading UI
</objective>

<execution_context>
@/Users/rasheedelhindi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rasheedelhindi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-web-frontend-mvp/04-RESEARCH.md
@.planning/phases/04-web-frontend-mvp/04-01-SUMMARY.md
@indexer-api/ponder.schema.ts
@indexer-api/src/api/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Import contract ABIs and configure addresses</name>
  <files>
    web/src/lib/contracts.ts
    web/src/types/market.ts
    web/src/types/position.ts
  </files>
  <action>
Extract ABIs from compiled contracts in `contracts/out/`.

Read ABIs from:
- contracts/out/Vault.sol/Vault.json -> extract `abi` field
- contracts/out/PredictionMarket.sol/PredictionMarket.json -> extract `abi` field
- contracts/out/MarketFactory.sol/MarketFactory.json -> extract `abi` field (for reading)

Create web/src/lib/contracts.ts:
```typescript
// ABIs extracted from contracts/out/*.json
export const vaultAbi = [...] as const  // Copy abi array from JSON
export const predictionMarketAbi = [...] as const
export const marketFactoryAbi = [...] as const

// Contract addresses from environment (testnet deployment deferred)
export const VAULT_ADDRESS = import.meta.env.VITE_VAULT_ADDRESS as `0x${string}` | undefined
export const MARKET_FACTORY_ADDRESS = import.meta.env.VITE_MARKET_FACTORY_ADDRESS as `0x${string}` | undefined

// USDC on Base Sepolia (for approvals)
export const USDC_ADDRESS = import.meta.env.VITE_USDC_ADDRESS as `0x${string}` | undefined
export const USDC_DECIMALS = 6
```

Create types from Ponder schema (web/src/types/market.ts):
```typescript
export interface Market {
  id: `0x${string}`
  conditionId: `0x${string}`
  questionId: `0x${string}`
  cityId: string  // 'NYC' | 'CHICAGO' | 'MIAMI' | 'AUSTIN'
  lowerBound: number
  upperBound: number
  resolutionTime: bigint
  createdAt: bigint
  volume: bigint
  yesPool: bigint
  noPool: bigint
  resolved: boolean
}

export interface WeatherData {
  current: { temperature: number; conditions: string }
  forecast: { high: number; low: number }
  cityName: string
}

export interface MarketWithWeather extends Market {
  weather: WeatherData | null
}
```

Create web/src/types/position.ts:
```typescript
export interface Position {
  id: string  // marketId-user-isYes
  marketId: `0x${string}`
  user: `0x${string}`
  isYes: boolean
  shares: bigint
  costBasis: bigint
}
```

Update web/.env.example with contract address placeholders.
  </action>
  <verify>
TypeScript compiles without errors. ABIs are valid (try importing in a test file).
  </verify>
  <done>ABIs exported as const for type inference. Address constants read from env vars. Types match Ponder schema.</done>
</task>

<task type="auto">
  <name>Task 2: Create GraphQL client and market/position hooks</name>
  <files>
    web/package.json
    web/src/lib/graphql.ts
    web/src/hooks/useMarkets.ts
    web/src/hooks/usePositions.ts
  </files>
  <action>
Install graphql-request:
```bash
cd web && npm install graphql-request graphql
```

Create web/src/lib/graphql.ts:
```typescript
import { GraphQLClient } from 'graphql-request'

const GRAPHQL_URL = import.meta.env.VITE_GRAPHQL_URL || 'http://localhost:42069/graphql'

export const graphqlClient = new GraphQLClient(GRAPHQL_URL)
```

Create web/src/hooks/useMarkets.ts:
```typescript
import { useQuery } from '@tanstack/react-query'
import { gql } from 'graphql-request'
import { graphqlClient } from '@/lib/graphql'
import type { Market } from '@/types/market'

// Note: Ponder generates plural table names with double 's' (marketss)
const MARKETS_QUERY = gql`
  query GetMarkets($orderBy: String, $orderDirection: String) {
    marketss(orderBy: $orderBy, orderDirection: $orderDirection) {
      items {
        id
        conditionId
        questionId
        cityId
        lowerBound
        upperBound
        resolutionTime
        createdAt
        volume
        yesPool
        noPool
        resolved
      }
    }
  }
`

interface MarketsResponse {
  marketss: { items: Market[] }
}

export function useMarkets(sortBy: 'volume' | 'createdAt' = 'volume') {
  return useQuery({
    queryKey: ['markets', sortBy],
    queryFn: async () => {
      const data = await graphqlClient.request<MarketsResponse>(MARKETS_QUERY, {
        orderBy: sortBy,
        orderDirection: 'desc',
      })
      return data.marketss.items
    },
    staleTime: 10_000, // 10 seconds
  })
}
```

Create web/src/hooks/usePositions.ts:
```typescript
import { useQuery } from '@tanstack/react-query'
import { gql } from 'graphql-request'
import { useAccount } from 'wagmi'
import { graphqlClient } from '@/lib/graphql'
import type { Position } from '@/types/position'

const POSITIONS_QUERY = gql`
  query GetPositions($user: String!) {
    positionss(where: { user: $user }) {
      items {
        id
        marketId
        user
        isYes
        shares
        costBasis
      }
    }
  }
`

interface PositionsResponse {
  positionss: { items: Position[] }
}

export function usePositions() {
  const { address } = useAccount()

  return useQuery({
    queryKey: ['positions', address],
    queryFn: async () => {
      if (!address) return []
      const data = await graphqlClient.request<PositionsResponse>(POSITIONS_QUERY, {
        user: address.toLowerCase(),
      })
      return data.positionss.items
    },
    enabled: !!address,
    staleTime: 5_000, // 5 seconds - positions change more frequently
  })
}
```

Add VITE_GRAPHQL_URL to .env.example.
  </action>
  <verify>
```typescript
// In a component, temporarily test:
const { data: markets, isLoading } = useMarkets()
console.log('Markets:', markets)
// Should log array (empty if no markets deployed)
```
  </verify>
  <done>GraphQL client configured. useMarkets returns markets sorted by volume. usePositions returns user positions when connected.</done>
</task>

<task type="auto">
  <name>Task 3: Create combined data hooks and vault balance hook</name>
  <files>
    web/src/hooks/useMarketsWithWeather.ts
    web/src/hooks/useVault.ts
  </files>
  <action>
Create web/src/hooks/useMarketsWithWeather.ts:
```typescript
import { useQuery } from '@tanstack/react-query'
import type { MarketWithWeather } from '@/types/market'

const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:42069'

interface MarketsWithWeatherResponse {
  markets: MarketWithWeather[]
  totalMarkets: number
  weatherCacheStats: { hits: number; misses: number }
}

export function useMarketsWithWeather() {
  return useQuery({
    queryKey: ['markets-with-weather'],
    queryFn: async (): Promise<MarketWithWeather[]> => {
      const response = await fetch(`${API_URL}/markets-with-weather`)
      if (!response.ok) throw new Error('Failed to fetch markets')
      const data: MarketsWithWeatherResponse = await response.json()
      // Sort by volume descending (hot markets first)
      return data.markets.sort((a, b) =>
        Number(BigInt(b.volume) - BigInt(a.volume))
      )
    },
    staleTime: 30_000, // 30 seconds - weather updates less frequently
  })
}
```

Create web/src/hooks/useVault.ts for reading vault balance and writing deposit/withdraw:
```typescript
import { useReadContract, useWriteContract, useWaitForTransactionReceipt } from 'wagmi'
import { useQueryClient } from '@tanstack/react-query'
import { vaultAbi, VAULT_ADDRESS, USDC_DECIMALS } from '@/lib/contracts'
import { parseUnits, formatUnits } from 'viem'

export function useVaultBalance(address: `0x${string}` | undefined) {
  return useReadContract({
    address: VAULT_ADDRESS,
    abi: vaultAbi,
    functionName: 'balanceOf',
    args: address ? [address] : undefined,
    query: {
      enabled: !!address && !!VAULT_ADDRESS,
    },
  })
}

export function useVaultDeposit() {
  const queryClient = useQueryClient()
  const { data: hash, isPending, writeContract, error } = useWriteContract()

  const { isLoading: isConfirming, isSuccess } = useWaitForTransactionReceipt({
    hash,
  })

  const deposit = (amount: string) => {
    if (!VAULT_ADDRESS) throw new Error('Vault address not configured')
    writeContract({
      address: VAULT_ADDRESS,
      abi: vaultAbi,
      functionName: 'deposit',
      args: [parseUnits(amount, USDC_DECIMALS)],
    })
  }

  // Invalidate queries on success
  if (isSuccess) {
    queryClient.invalidateQueries({ queryKey: ['vaultBalance'] })
  }

  return { deposit, isPending, isConfirming, isSuccess, error, hash }
}

export function useVaultWithdraw() {
  const queryClient = useQueryClient()
  const { data: hash, isPending, writeContract, error } = useWriteContract()

  const { isLoading: isConfirming, isSuccess } = useWaitForTransactionReceipt({
    hash,
  })

  const withdraw = (amount: string) => {
    if (!VAULT_ADDRESS) throw new Error('Vault address not configured')
    writeContract({
      address: VAULT_ADDRESS,
      abi: vaultAbi,
      functionName: 'withdraw',
      args: [parseUnits(amount, USDC_DECIMALS)],
    })
  }

  if (isSuccess) {
    queryClient.invalidateQueries({ queryKey: ['vaultBalance'] })
  }

  return { withdraw, isPending, isConfirming, isSuccess, error, hash }
}

// Helper to format vault balance for display
export function formatVaultBalance(balance: bigint | undefined): string {
  if (balance === undefined) return '0.00'
  return formatUnits(balance, USDC_DECIMALS)
}
```

Add VITE_API_URL to .env.example.
  </action>
  <verify>
```typescript
// Temporarily in a component:
const { data, isLoading } = useMarketsWithWeather()
console.log('Markets with weather:', data)
// Should log markets with weather property attached
```
  </verify>
  <done>useMarketsWithWeather returns markets with embedded weather data. useVault hooks provide balance reading and deposit/withdraw with transaction confirmation.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles with `npm run build` (no type errors)
2. useMarkets hook fetches from GraphQL and returns typed data
3. usePositions hook is enabled only when wallet connected
4. useMarketsWithWeather hook fetches from REST endpoint
5. useVault hooks read balance and prepare write transactions
6. All hooks use TanStack Query with proper staleTime
</verification>

<success_criteria>
- [ ] Contract ABIs extracted and typed (as const for type inference)
- [ ] GraphQL client configured pointing to Ponder
- [ ] useMarkets returns Market[] sorted by volume
- [ ] usePositions returns Position[] for connected user
- [ ] useMarketsWithWeather returns MarketWithWeather[] with weather data
- [ ] useVault hooks provide balance read and deposit/withdraw write
- [ ] All hooks integrate with TanStack Query caching
- [ ] No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-web-frontend-mvp/04-02-SUMMARY.md`
</output>
