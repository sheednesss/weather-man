---
phase: 03-indexing-backend
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - indexer-api/README.md
autonomous: false

must_haves:
  truths:
    - "GraphQL API returns markets sorted by volume"
    - "Weather endpoints return cached data"
    - "Full API is ready for frontend integration"
  artifacts:
    - path: "indexer-api/README.md"
      provides: "API documentation for frontend developers"
      contains: "GraphQL"
  key_links:
    - from: "Frontend"
      to: "indexer-api GraphQL"
      via: "HTTP queries to /graphql"
      pattern: "markets.*volume"
---

<objective>
Verify the complete indexer API works end-to-end and document for frontend.

Purpose: Ensure Phase 3 success criteria are met before proceeding to frontend. Create API documentation.
Output: Verified working API, README with query examples for frontend integration.
</objective>

<execution_context>
@/Users/rasheedelhindi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rasheedelhindi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-indexing-backend/03-01-SUMMARY.md
@.planning/phases/03-indexing-backend/03-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API documentation README</name>
  <files>
    indexer-api/README.md
  </files>
  <action>
    Create README.md with:

    1. Overview section explaining what the indexer does

    2. Setup instructions:
       - Copy .env.example to .env
       - Configure RPC URL, factory address, start block
       - npm install
       - npm run dev

    3. GraphQL API examples:
       ```graphql
       # Hot markets (sorted by volume)
       query HotMarkets {
         markets(orderBy: "volume", orderDirection: "desc", limit: 10) {
           items {
             id
             cityId
             volume
             yesPool
             noPool
             resolutionTime
             resolved
           }
         }
       }

       # Markets for specific city
       query MarketsByCity($cityId: String!) {
         markets(where: { cityId: $cityId }) {
           items {
             id
             volume
             lowerBound
             upperBound
           }
         }
       }

       # User positions
       query UserPositions($user: String!) {
         positions(where: { user: $user }) {
           items {
             marketId
             isYes
             shares
             costBasis
           }
         }
       }

       # Recent trades
       query RecentTrades {
         trades(orderBy: "timestamp", orderDirection: "desc", limit: 20) {
           items {
             marketId
             user
             amount
             isYes
             isBuy
             timestamp
           }
         }
       }
       ```

    4. REST API endpoints:
       - GET /weather/:cityId - Current weather + 7-day forecast
       - GET /weather - All cities weather
       - GET /markets-with-weather - Markets with embedded weather

    5. Response format examples

    6. Environment variables reference
  </action>
  <verify>
    - README.md exists with query examples
    - All documented endpoints actually work
  </verify>
  <done>
    API documentation complete for frontend integration.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete indexer API with:
    - Ponder indexer tracking MarketCreated, Buy, Sell events
    - GraphQL API for markets, trades, positions
    - Hot markets query (volume sorting)
    - Weather endpoints with 15-min cache
    - Combined markets+weather endpoint
  </what-built>
  <how-to-verify>
    1. Start the indexer:
       ```bash
       cd indexer-api
       npm run dev
       ```

    2. Open GraphQL playground at http://localhost:42069

    3. Test hot markets query:
       ```graphql
       {
         markets(orderBy: "volume", orderDirection: "desc") {
           items { id cityId volume }
         }
       }
       ```
       Expected: Returns array (may be empty if no events indexed yet)

    4. Test weather endpoint:
       ```bash
       curl http://localhost:42069/weather/NYC
       ```
       Expected: JSON with temperature, conditions, forecast array

    5. Test all weather:
       ```bash
       curl http://localhost:42069/weather
       ```
       Expected: Object with NYC, CHICAGO, MIAMI, AUSTIN keys

    6. Test markets with weather:
       ```bash
       curl http://localhost:42069/markets-with-weather
       ```
       Expected: Markets array with weather embedded

    7. Verify cache (second weather request should be fast):
       ```bash
       time curl http://localhost:42069/weather/NYC
       time curl http://localhost:42069/weather/NYC
       ```
       Expected: Second request completes in <50ms

    **Phase 3 Success Criteria to verify:**
    - [ ] GraphQL API returns markets with real-time pricing (yesPool/noPool)
    - [ ] Markets can be sorted by volume (hot markets)
    - [ ] Current weather displays for each market location
    - [ ] Weather forecast displays for each market location
  </how-to-verify>
  <resume-signal>Type "approved" if all checks pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. Indexer runs without errors
2. GraphQL playground accessible
3. Hot markets query works (order by volume)
4. Weather endpoints return valid data
5. Cache hit on repeated requests
6. All 4 cities have weather data
</verification>

<success_criteria>
- README.md documents all API endpoints
- GraphQL queries work as documented
- Weather endpoints return expected format
- Phase 3 success criteria verified by human
</success_criteria>

<output>
After completion, create `.planning/phases/03-indexing-backend/03-03-SUMMARY.md`
</output>
