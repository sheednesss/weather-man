---
phase: 03-indexing-backend
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - indexer-api/src/lib/weather.ts
  - indexer-api/src/lib/cities.ts
  - indexer-api/src/api/index.ts
  - indexer-api/.env.example
autonomous: true

must_haves:
  truths:
    - "Weather endpoint returns current temperature for city"
    - "Weather endpoint returns 7-day forecast"
    - "Weather data is cached to avoid API rate limits"
    - "Markets endpoint includes weather data for each city"
  artifacts:
    - path: "indexer-api/src/lib/weather.ts"
      provides: "Weather fetching with TTL cache"
      contains: "NodeCache"
    - path: "indexer-api/src/lib/cities.ts"
      provides: "City coordinates matching CityLib.sol"
      contains: "NYC"
    - path: "indexer-api/src/api/index.ts"
      provides: "Custom Hono routes for weather endpoints"
      contains: "app.get"
  key_links:
    - from: "indexer-api/src/api/index.ts"
      to: "indexer-api/src/lib/weather.ts"
      via: "getWeather() call in route handler"
      pattern: "getWeather"
    - from: "indexer-api/src/lib/weather.ts"
      to: "Open-Meteo API"
      via: "axios HTTP request"
      pattern: "api\\.open-meteo\\.com"
---

<objective>
Add weather API integration with caching and custom endpoints.

Purpose: Enable frontend to display current weather conditions and forecasts alongside market data. Weather API data is cached to avoid rate limits.
Output: /weather/:cityId endpoint returning cached weather data, /markets-with-weather endpoint combining market and weather data.
</objective>

<execution_context>
@/Users/rasheedelhindi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rasheedelhindi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-indexing-backend/03-RESEARCH.md
@.planning/phases/03-indexing-backend/03-01-SUMMARY.md

# Reference existing oracle weather patterns
@oracle-service/src/providers/openmeteo.ts
@oracle-service/src/config/constants.ts
@contracts/src/libraries/CityLib.sol
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create city coordinates and weather caching module</name>
  <files>
    indexer-api/src/lib/cities.ts
    indexer-api/src/lib/weather.ts
  </files>
  <action>
    1. Create src/lib/cities.ts:
       - Define CITIES object matching CityLib.sol coordinates
       - Cities: NYC, CHICAGO, MIAMI, AUSTIN
       - Coordinates: use actual lat/lon (unscaled, e.g., 40.7128 not 407128)
       - Include city names for display

       ```typescript
       export const CITIES = {
         NYC: { name: "New York City", lat: 40.7128, lon: -74.0060 },
         CHICAGO: { name: "Chicago", lat: 41.8781, lon: -87.6298 },
         MIAMI: { name: "Miami", lat: 25.7617, lon: -80.1918 },
         AUSTIN: { name: "Austin", lat: 30.2672, lon: -97.7431 },
       } as const;

       export type CityId = keyof typeof CITIES;
       ```

    2. Create src/lib/weather.ts:
       - Import NodeCache and axios
       - Create cache with 15-minute TTL (900 seconds)
       - Define WeatherData interface: { temperature, conditions, forecast[] }
       - Define ForecastDay: { date, high, low, conditions }
       - Implement getWeather(cityId):
         - Check cache first, return if hit
         - Fetch from Open-Meteo API (no API key required):
           `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,weather_code&daily=temperature_2m_max,temperature_2m_min,weather_code&forecast_days=7&temperature_unit=fahrenheit`
         - Parse response into WeatherData structure
         - Map weather_code to human-readable conditions (0=Clear, 1-3=Partly Cloudy, etc.)
         - Cache result
         - Return data
       - Handle errors gracefully, return null if fetch fails

    Weather code mapping (WMO codes):
    - 0: Clear sky
    - 1, 2, 3: Partly cloudy
    - 45, 48: Foggy
    - 51, 53, 55: Drizzle
    - 61, 63, 65: Rain
    - 71, 73, 75: Snow
    - 80, 81, 82: Rain showers
    - 95, 96, 99: Thunderstorm
  </action>
  <verify>
    - TypeScript compiles: `npm run typecheck`
    - No import errors
  </verify>
  <done>
    Weather module fetches from Open-Meteo with 15-min cache. City coordinates match CityLib.sol.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add custom Hono API routes for weather</name>
  <files>
    indexer-api/src/api/index.ts
  </files>
  <action>
    1. Create src/api/index.ts with Hono app:
       - Import Hono, graphql from ponder, db from "ponder:api", schema from "ponder:schema"
       - Import getWeather from lib/weather
       - Import CITIES, CityId from lib/cities

    2. Set up routes:
       ```typescript
       import { Hono } from "hono";
       import { graphql } from "ponder";
       import { db } from "ponder:api";
       import * as schema from "ponder:schema";
       import { desc } from "ponder";
       import { getWeather } from "../lib/weather";
       import { CITIES, CityId } from "../lib/cities";

       const app = new Hono();

       // Auto-generated GraphQL API
       app.use("/graphql", graphql({ db, schema }));
       app.use("/", graphql({ db, schema }));

       // Weather for single city
       app.get("/weather/:cityId", async (c) => {
         const cityId = c.req.param("cityId").toUpperCase() as CityId;
         if (!(cityId in CITIES)) {
           return c.json({ error: "Invalid city" }, 400);
         }
         const weather = await getWeather(cityId);
         if (!weather) {
           return c.json({ error: "Weather unavailable" }, 503);
         }
         return c.json(weather);
       });

       // All cities weather
       app.get("/weather", async (c) => {
         const results: Record<string, any> = {};
         for (const cityId of Object.keys(CITIES) as CityId[]) {
           results[cityId] = await getWeather(cityId);
         }
         return c.json(results);
       });

       // Markets with weather (combined endpoint)
       app.get("/markets-with-weather", async (c) => {
         const markets = await db
           .select()
           .from(schema.markets)
           .orderBy(desc(schema.markets.volume))
           .limit(50);

         const marketsWithWeather = await Promise.all(
           markets.map(async (m) => ({
             ...m,
             weather: await getWeather(m.cityId as CityId),
           }))
         );
         return c.json(marketsWithWeather);
       });

       export default app;
       ```

    3. Verify Ponder's API routing:
       - Ponder 0.16+ auto-discovers src/api/index.ts (or api/index.ts)
       - Export default Hono app
       - GraphQL remains at / and /graphql
       - Custom routes at /weather/:cityId, /weather, /markets-with-weather
  </action>
  <verify>
    - `npm run dev` starts without errors
    - `curl http://localhost:42069/weather/NYC` returns weather JSON
    - `curl http://localhost:42069/weather` returns all cities
    - GraphQL at http://localhost:42069/graphql still works
  </verify>
  <done>
    Custom Hono routes serve weather data. /weather/:cityId for single city, /weather for all, /markets-with-weather for combined data.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify caching behavior and API response format</name>
  <files>
    indexer-api/.env.example
  </files>
  <action>
    1. Update .env.example to document weather (no keys needed for Open-Meteo):
       ```
       # Weather API (Open-Meteo is free, no key needed)
       # Cache TTL is 15 minutes (900 seconds)
       ```

    2. Test cache behavior:
       - Make request to /weather/NYC
       - Note response time
       - Make second request immediately
       - Second request should be <10ms (cached)

    3. Verify response format matches requirements:
       ```json
       {
         "temperature": 72.5,
         "conditions": "Partly Cloudy",
         "forecast": [
           { "date": "2026-01-29", "high": 75, "low": 62, "conditions": "Clear" },
           ...
         ]
       }
       ```

    4. Test /markets-with-weather response:
       - Should return markets array with weather object embedded
       - Weather should be present for each market's cityId
       - Markets should be sorted by volume (descending)

    5. Verify error handling:
       - Invalid cityId returns 400
       - If Open-Meteo is down, returns 503 (not crash)
  </action>
  <verify>
    - Second /weather/NYC request is <10ms (cache hit)
    - Response includes temperature, conditions, forecast array
    - /markets-with-weather includes weather for each market
  </verify>
  <done>
    Weather caching works with 15-min TTL. API responses match expected format for frontend consumption.
  </done>
</task>

</tasks>

<verification>
1. /weather/NYC returns current temperature and 7-day forecast
2. /weather returns all 4 cities
3. /markets-with-weather returns markets with embedded weather
4. Cache hit on second request (fast response)
5. GraphQL API still works at /graphql
</verification>

<success_criteria>
- Weather endpoints return current conditions (temperature, conditions string)
- Weather endpoints return 7-day forecast (date, high, low, conditions)
- Cache prevents repeated API calls within 15 minutes
- Combined markets+weather endpoint works for frontend
- Invalid cityId returns 400 error
- API failures return 503 (graceful degradation)
</success_criteria>

<output>
After completion, create `.planning/phases/03-indexing-backend/03-02-SUMMARY.md`
</output>
