---
phase: 01-smart-contract-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - contracts/src/MarketFactory.sol
  - contracts/src/PredictionMarket.sol
  - contracts/src/libraries/PositionLib.sol
  - contracts/test/PredictionMarket.t.sol
autonomous: true

must_haves:
  truths:
    - "User can buy YES outcome shares on a market"
    - "User can buy NO outcome shares on a market"
    - "User can sell YES outcome shares back to the market"
    - "User can sell NO outcome shares back to the market"
    - "User can query their cost basis (entry price) for each position"
  artifacts:
    - path: "contracts/src/MarketFactory.sol"
      provides: "Market creation and registry"
      exports: ["createMarket", "getMarket"]
    - path: "contracts/src/PredictionMarket.sol"
      provides: "Trading logic via CTF with cost basis tracking"
      exports: ["buy", "sell", "getPositionBalance", "getCostBasis"]
    - path: "contracts/src/libraries/PositionLib.sol"
      provides: "CTF position ID calculations"
      min_lines: 15
  key_links:
    - from: "contracts/src/PredictionMarket.sol"
      to: "IConditionalTokens"
      via: "splitPosition for buy, mergePositions for sell"
      pattern: "splitPosition|mergePositions"
    - from: "contracts/src/MarketFactory.sol"
      to: "contracts/src/PredictionMarket.sol"
      via: "factory deploys market instances"
      pattern: "new PredictionMarket"
    - from: "contracts/src/PredictionMarket.sol"
      to: "costBasis mapping"
      via: "tracks cumulative USDC spent per user per outcome"
      pattern: "costBasis\\[.*\\]\\[.*\\]"
---

<objective>
Implement MarketFactory and PredictionMarket contracts that enable users to buy/sell YES and NO outcome shares using the Gnosis Conditional Tokens Framework, with cost basis tracking for P&L calculation.

Purpose: Core trading functionality. Users deposit USDC, receive outcome tokens (YES/NO shares), can sell them back. Uses CTF splitPosition (buy) and mergePositions (sell). Tracks entry prices to enable frontend P&L display.
Output: Working market contracts where users can trade YES/NO positions on binary outcome markets and query their cost basis.
</objective>

<execution_context>
@/Users/rasheedelhindi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rasheedelhindi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-smart-contract-foundation/01-RESEARCH.md
@.planning/phases/01-smart-contract-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PositionLib and MarketFactory</name>
  <files>
    contracts/src/libraries/PositionLib.sol
    contracts/src/MarketFactory.sol
  </files>
  <action>
Create `contracts/src/libraries/PositionLib.sol`:
- Library for CTF position ID calculations
- `getConditionId(address oracle, bytes32 questionId, uint256 outcomeSlotCount) pure returns (bytes32)`:
  - Return `keccak256(abi.encodePacked(oracle, questionId, outcomeSlotCount))`
- `getCollectionId(bytes32 parentCollectionId, bytes32 conditionId, uint256 indexSet) pure returns (bytes32)`:
  - Return `keccak256(abi.encodePacked(parentCollectionId, conditionId, indexSet))`
- `getPositionId(address collateralToken, bytes32 collectionId) pure returns (uint256)`:
  - Return `uint256(keccak256(abi.encodePacked(collateralToken, collectionId)))`
- Constants: `uint256 constant YES_INDEX = 1;` (0b01), `uint256 constant NO_INDEX = 2;` (0b10)

Create `contracts/src/MarketFactory.sol`:
- Import Ownable from OpenZeppelin (for admin functions later)
- Import IConditionalTokens, PredictionMarket
- State:
  - `IConditionalTokens public immutable conditionalTokens;`
  - `IERC20 public immutable usdc;`
  - `mapping(bytes32 => address) public markets;` // conditionId => market address
  - `uint256 public marketCount;`
- Constructor: takes CTF address and USDC address
- `createMarket(bytes32 questionId, uint256 resolutionTime) external returns (address)`:
  - Calculate conditionId using PositionLib (oracle = address(this) for MVP)
  - Call `conditionalTokens.prepareCondition(address(this), questionId, 2)` for binary outcome
  - Deploy new PredictionMarket with conditionId, CTF address, USDC address
  - Store in markets mapping
  - Emit MarketCreated(conditionId, marketAddress, questionId, resolutionTime)
  - Increment marketCount
  - Return market address
- `getMarket(bytes32 conditionId) view returns (address)` - lookup market by conditionId
- Custom errors: `error MarketAlreadyExists()`, `error InvalidResolutionTime()`
  </action>
  <verify>
Run `cd contracts && forge build` - compiles without errors.
Check PositionLib exports YES_INDEX and NO_INDEX constants.
  </verify>
  <done>
PositionLib provides position ID calculations. MarketFactory can create markets via CTF prepareCondition.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement PredictionMarket trading contract with cost basis tracking</name>
  <files>
    contracts/src/PredictionMarket.sol
  </files>
  <action>
Create `contracts/src/PredictionMarket.sol`:
- Import SafeERC20, IERC20, ReentrancyGuard
- Import IConditionalTokens, PositionLib
- Inherit ReentrancyGuard

State:
- `IConditionalTokens public immutable conditionalTokens;`
- `IERC20 public immutable usdc;`
- `bytes32 public immutable conditionId;`
- `address public immutable factory;`
- `uint256 public yesPool;` // Total USDC in YES outcome
- `uint256 public noPool;` // Total USDC in NO outcome
- `bool public resolved;`
- `mapping(address => mapping(bool => uint256)) public costBasis;` // user => isYes => total USDC spent (for P&L calculation)

Constructor: takes conditionId, CTF address, USDC address, factory address

**buy(uint256 amount, bool isYes) external nonReentrant:**
1. Check amount > 0, market not resolved
2. Pull USDC from user: `usdc.safeTransferFrom(msg.sender, address(this), amount)`
3. Approve CTF to spend USDC: `usdc.approve(address(conditionalTokens), amount)`
4. Create partition array: `uint256[] memory partition = new uint256[](2); partition[0] = 1; partition[1] = 2;`
5. Call `conditionalTokens.splitPosition(usdc, bytes32(0), conditionId, partition, amount)`
   - This gives the market contract both YES and NO tokens
6. Calculate position IDs using PositionLib
7. Transfer the requested outcome tokens to user:
   - If isYes: transfer YES tokens to msg.sender
   - Keep the opposite tokens (NO) in contract as pool reserve
8. Update pool: `if (isYes) yesPool += amount; else noPool += amount;`
9. **Track cost basis: `costBasis[msg.sender][isYes] += amount;`** (cumulative USDC spent on this outcome)
10. Emit Buy(msg.sender, amount, isYes)

**sell(uint256 amount, bool isYes) external nonReentrant:**
1. Check amount > 0, market not resolved
2. Check user has sufficient outcome tokens (query CTF balanceOf)
3. Calculate position IDs
4. Transfer outcome tokens FROM user TO contract (CTF is ERC-1155, use safeTransferFrom)
   - Note: Contract needs to be approved on CTF for user's tokens OR use CTF's setApprovalForAll
   - Alternative: User must call CTF.setApprovalForAll(marketAddress, true) first
5. If contract has matching opposite tokens:
   - Call `conditionalTokens.mergePositions(usdc, bytes32(0), conditionId, partition, amount)`
   - This returns USDC to the contract
   - Transfer USDC to user
6. Update pool: reduce appropriate pool
7. **Reduce cost basis proportionally:** Calculate proportion sold = amount / (previous balance + amount), reduce costBasis by that proportion. Or simpler for MVP: reduce costBasis by USDC received (capped at current costBasis)
8. Emit Sell(msg.sender, amount, isYes)

**getCostBasis(address user, bool isYes) external view returns (uint256):**
- Returns `costBasis[user][isYes]` - total USDC the user has spent on this outcome
- Frontend calculates: P&L = currentValue - costBasis
- currentValue = positionBalance * currentPrice (from oracle/AMM in later phases)

**getPositionBalance(address user, bool isYes) view returns (uint256):**
- Calculate position ID for YES or NO
- Return `conditionalTokens.balanceOf(user, positionId)`

**Helper functions:**
- `getYesPositionId() view returns (uint256)` - cached or calculated
- `getNoPositionId() view returns (uint256)` - cached or calculated
- `getTotalPool() view returns (uint256)` - yesPool + noPool

Custom errors: `error MarketResolved()`, `error InsufficientShares()`, `error ZeroAmount()`

Note on ERC-1155: The market contract must implement IERC1155Receiver to receive outcome tokens, or use a different flow. For MVP, the simpler approach is:
- On buy: splitPosition gives contract both tokens, transfer requested token to user
- On sell: user approves contract on CTF, contract pulls user's tokens, merges if it has both sides
  </action>
  <verify>
Run `cd contracts && forge build` - compiles without errors.
Grep for "splitPosition" in PredictionMarket.sol - should find buy function.
Grep for "mergePositions" in PredictionMarket.sol - should find sell function.
Grep for "costBasis" in PredictionMarket.sol - should find mapping and getCostBasis function.
  </verify>
  <done>
PredictionMarket allows buying YES/NO shares via CTF splitPosition and selling via mergePositions. Cost basis is tracked per user per outcome to enable P&L calculation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Write comprehensive market tests including cost basis</name>
  <files>
    contracts/test/PredictionMarket.t.sol
    contracts/test/mocks/MockConditionalTokens.sol
  </files>
  <action>
Create `contracts/test/mocks/MockConditionalTokens.sol`:
- Implement IConditionalTokens interface with mock behavior
- Track conditions prepared, positions split/merged
- Store balances per position ID per address
- `splitPosition`: mint outcome tokens to caller, take collateral
- `mergePositions`: burn outcome tokens from caller, return collateral
- `balanceOf`: return stored balance
- This allows testing without deploying real CTF

Create `contracts/test/PredictionMarket.t.sol`:
- Import Test, console from forge-std
- Setup:
  - Deploy mock USDC (can use forge-std's deal cheatcode for simpler setup)
  - Deploy mock or real CTF
  - Deploy MarketFactory
  - Create a test market
  - Fund test users with USDC

Test cases:
- `test_CreateMarket_EmitsEvent()` - factory creates market, emits event
- `test_Buy_Yes_ReceivesTokens()`:
  - User approves USDC to market
  - User calls buy(100e6, true) for 100 USDC on YES
  - Check user's USDC decreased by 100
  - Check user has YES position tokens
  - Check yesPool increased by 100
- `test_Buy_No_ReceivesTokens()` - same for NO outcome
- `test_Sell_Yes_ReturnsUSDC()`:
  - User buys YES, then sells back
  - Check USDC returned (may not be full amount if no matching NO)
  - This tests the mergePositions flow
- `test_Sell_RevertsIfNoPosition()` - user tries to sell without holding tokens
- `test_GetPositionBalance_ReturnsCorrect()` - check balance queries work
- **`test_CostBasis_TrackedOnBuy()`:**
  - User buys 100 USDC of YES
  - Check getCostBasis(user, true) == 100e6
  - User buys another 50 USDC of YES
  - Check getCostBasis(user, true) == 150e6
- **`test_CostBasis_ReducedOnSell()`:**
  - User buys 100 USDC of YES
  - User sells half their position
  - Check costBasis reduced appropriately
- **`test_CostBasis_SeparateForYesAndNo()`:**
  - User buys 100 USDC of YES
  - User buys 50 USDC of NO
  - Check getCostBasis(user, true) == 100e6
  - Check getCostBasis(user, false) == 50e6
- `testFuzz_BuySell_Symmetric(uint256 amount)`:
  - Bound amount 1e6 to 1e12 (1 to 1M USDC)
  - Buy, then sell full amount
  - Verify pool states consistent

Note: Full integration with real CTF requires deploying CTF contracts. For unit tests, mock is sufficient. Integration tests can use fork mode with deployed CTF.
  </action>
  <verify>
Run `cd contracts && forge test -vv` - all tests pass.
Run `cd contracts && forge test --match-test testFuzz -vvv` - fuzz tests find no counterexamples.
Run `cd contracts && forge test --match-test CostBasis -vv` - cost basis tests pass.
  </verify>
  <done>
Market trading tests pass. Users can buy/sell YES and NO outcome shares. Cost basis tracking verified - enables PORT-02 (P&L display) in frontend.
  </done>
</task>

</tasks>

<verification>
1. `cd contracts && forge build` compiles all contracts
2. `cd contracts && forge test` runs all tests successfully
3. MarketFactory.sol can create markets with prepareCondition
4. PredictionMarket.sol implements buy() with splitPosition
5. PredictionMarket.sol implements sell() with mergePositions
6. PredictionMarket.sol tracks costBasis mapping and exposes getCostBasis()
7. Tests cover buy YES, buy NO, sell YES, sell NO scenarios
8. Tests cover cost basis tracking for P&L calculation
9. All functions use ReentrancyGuard and SafeERC20
</verification>

<success_criteria>
- MarketFactory creates markets by calling CTF prepareCondition
- PredictionMarket.buy() splits USDC into YES/NO tokens, gives user requested outcome
- PredictionMarket.buy() tracks cumulative cost basis per user per outcome
- PredictionMarket.sell() merges outcome tokens back into USDC when possible
- PredictionMarket.getCostBasis() returns total USDC spent by user on each outcome
- Users can query their position balances
- All trading functions protected with ReentrancyGuard
- Tests demonstrate full buy/sell cycle for both outcomes
- Cost basis tests verify P&L calculation data is available (enables PORT-02)
</success_criteria>

<output>
After completion, create `.planning/phases/01-smart-contract-foundation/01-02-SUMMARY.md`
</output>
