---
phase: 01-smart-contract-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - contracts/foundry.toml
  - contracts/.env.example
  - contracts/src/interfaces/IConditionalTokens.sol
  - contracts/src/interfaces/IUSDC.sol
  - contracts/src/Vault.sol
  - contracts/test/Vault.t.sol
autonomous: true

must_haves:
  truths:
    - "User can deposit USDC into the contract"
    - "User can withdraw USDC from the contract"
    - "Contract balances update correctly after deposit/withdraw"
  artifacts:
    - path: "contracts/foundry.toml"
      provides: "Foundry project configuration"
      contains: "base_sepolia"
    - path: "contracts/src/Vault.sol"
      provides: "USDC custody with deposit/withdraw"
      exports: ["deposit", "withdraw", "balanceOf"]
    - path: "contracts/src/interfaces/IConditionalTokens.sol"
      provides: "CTF interface for downstream contracts"
      min_lines: 20
  key_links:
    - from: "contracts/src/Vault.sol"
      to: "USDC contract"
      via: "SafeERC20 safeTransferFrom/safeTransfer"
      pattern: "safeTransfer"
---

<objective>
Set up Foundry project with OpenZeppelin and CTF dependencies, implement USDC deposit/withdraw vault with proper security patterns.

Purpose: Foundation for all smart contract work. Establishes project structure, security patterns (SafeERC20, ReentrancyGuard, CEI), and basic USDC custody that markets will build on.
Output: Working Foundry project with Vault contract that handles USDC deposits and withdrawals.
</objective>

<execution_context>
@/Users/rasheedelhindi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rasheedelhindi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-smart-contract-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Foundry project with dependencies</name>
  <files>
    contracts/foundry.toml
    contracts/.env.example
    contracts/remappings.txt
  </files>
  <action>
Create `contracts/` directory at project root. Initialize Foundry project:

```bash
mkdir -p contracts && cd contracts
forge init --no-commit
```

Install dependencies:
```bash
forge install OpenZeppelin/openzeppelin-contracts@v5.4.0 --no-commit
forge install gnosis/conditional-tokens-contracts --no-commit
forge install foundry-rs/forge-std --no-commit
```

Configure `foundry.toml` per research:
- solc = "0.8.24"
- optimizer = true, runs = 200
- Add base_sepolia RPC endpoint
- Add fuzz runs = 1000
- Add invariant config

Create `remappings.txt`:
```
@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/
@gnosis.pm/conditional-tokens-contracts/=lib/conditional-tokens-contracts/
forge-std/=lib/forge-std/src/
```

Create `.env.example` with:
- BASE_SEPOLIA_RPC
- ETHERSCAN_API_KEY (for BaseScan)
- PRIVATE_KEY
- USDC_ADDRESS=0x036cbd53842c5426634e7929541ec2318f3dcf7e

Delete default Counter.sol and Counter.t.sol files created by forge init.
  </action>
  <verify>
Run `cd contracts && forge build` - should compile with no errors.
Verify `lib/` contains openzeppelin-contracts, conditional-tokens-contracts, forge-std.
  </verify>
  <done>
Foundry project compiles successfully with all dependencies installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CTF and USDC interfaces</name>
  <files>
    contracts/src/interfaces/IConditionalTokens.sol
    contracts/src/interfaces/IUSDC.sol
  </files>
  <action>
Create `contracts/src/interfaces/IConditionalTokens.sol`:
- Interface for Gnosis CTF with key functions:
  - `prepareCondition(address oracle, bytes32 questionId, uint256 outcomeSlotCount)`
  - `splitPosition(IERC20 collateralToken, bytes32 parentCollectionId, bytes32 conditionId, uint256[] partition, uint256 amount)`
  - `mergePositions(IERC20 collateralToken, bytes32 parentCollectionId, bytes32 conditionId, uint256[] partition, uint256 amount)`
  - `redeemPositions(IERC20 collateralToken, bytes32 parentCollectionId, bytes32 conditionId, uint256[] indexSets)`
  - `reportPayouts(bytes32 questionId, uint256[] payouts)`
  - `getConditionId(address oracle, bytes32 questionId, uint256 outcomeSlotCount) view returns (bytes32)`
  - `getCollectionId(bytes32 parentCollectionId, bytes32 conditionId, uint256 indexSet) view returns (bytes32)`
  - `getPositionId(IERC20 collateralToken, bytes32 collectionId) view returns (uint256)`
  - `balanceOf(address account, uint256 id) view returns (uint256)`
  - `payoutNumerators(bytes32 conditionId, uint256 index) view returns (uint256)`
  - `payoutDenominator(bytes32 conditionId) view returns (uint256)`

Use SPDX-License-Identifier: MIT and pragma solidity ^0.8.24.

Create `contracts/src/interfaces/IUSDC.sol`:
- Extend IERC20 from OpenZeppelin
- Add `decimals() returns (uint8)` if not already in IERC20
- This is just for documentation clarity; we'll use IERC20 with SafeERC20 in practice
  </action>
  <verify>
Run `cd contracts && forge build` - interfaces compile without errors.
  </verify>
  <done>
CTF and USDC interfaces exist and compile. Ready for contract implementation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement Vault contract with deposit/withdraw</name>
  <files>
    contracts/src/Vault.sol
    contracts/test/Vault.t.sol
  </files>
  <action>
Create `contracts/src/Vault.sol`:
- Import SafeERC20, IERC20 from OpenZeppelin
- Import ReentrancyGuard from @openzeppelin/contracts/utils/ReentrancyGuard.sol (OZ 5.x path!)
- Inherit ReentrancyGuard
- State:
  - `IERC20 public immutable usdc;`
  - `mapping(address => uint256) public balances;`
- Constructor: takes USDC address, validates not zero
- `deposit(uint256 amount) external nonReentrant`:
  - Check amount > 0
  - Use SafeERC20.safeTransferFrom to pull USDC from msg.sender
  - Update balances[msg.sender] += amount AFTER transfer (CEI pattern - transfer is safe with SafeERC20)
  - Emit Deposit(msg.sender, amount) event
- `withdraw(uint256 amount) external nonReentrant`:
  - Check balances[msg.sender] >= amount (CHECKS)
  - balances[msg.sender] -= amount (EFFECTS)
  - usdc.safeTransfer(msg.sender, amount) (INTERACTIONS)
  - Emit Withdraw(msg.sender, amount) event
- Use custom errors: `error InsufficientBalance()`, `error ZeroAmount()`, `error ZeroAddress()`
- USDC uses 6 decimals - amounts are in USDC native units (no internal normalization needed for simple custody)

Create `contracts/test/Vault.t.sol`:
- Import Test from forge-std
- Create mock USDC using forge-std MockERC20 or inline mock
- Test cases:
  - `test_Deposit_UpdatesBalance()` - deposit 100 USDC, check balance
  - `test_Withdraw_ReducesBalance()` - deposit then withdraw, check balance
  - `test_Withdraw_RevertsIfInsufficientBalance()` - try withdraw more than deposited
  - `test_Deposit_RevertsIfZeroAmount()` - try deposit 0
  - `testFuzz_DepositWithdraw(uint256 amount)` - bound amount 1 to 1e12, deposit then withdraw full amount, balance should be 0
  </action>
  <verify>
Run `cd contracts && forge test -vv` - all tests pass.
Run `cd contracts && forge test --match-test testFuzz -vvv` - fuzz tests pass with no counterexamples.
  </verify>
  <done>
Vault contract handles USDC deposit/withdraw with ReentrancyGuard, SafeERC20, CEI pattern. All tests pass including fuzz tests.
  </done>
</task>

</tasks>

<verification>
1. `cd contracts && forge build` compiles with no errors or warnings
2. `cd contracts && forge test` runs all tests successfully
3. `contracts/lib/` contains openzeppelin-contracts, conditional-tokens-contracts, forge-std
4. Vault.sol uses SafeERC20 (grep for "using SafeERC20")
5. Vault.sol uses ReentrancyGuard (grep for "nonReentrant")
6. Vault.sol uses CEI pattern (state changes before external calls in withdraw)
</verification>

<success_criteria>
- Foundry project initialized with correct dependencies and configuration
- CTF interface ready for market contracts
- Vault contract deposits/withdraws USDC with proper security
- All unit tests and fuzz tests pass
- Project structure matches research recommendations
</success_criteria>

<output>
After completion, create `.planning/phases/01-smart-contract-foundation/01-01-SUMMARY.md`
</output>
